本篇关键词：、、、


[下载 >> 离线文档.鸿蒙内核源码分析(百篇博客分析.挖透鸿蒙内核).pdf](https://weharmonyos.oss-cn-hangzhou.aliyuncs.com/resources/pdf/鸿蒙内核源码分析(百篇博客分析.挖透鸿蒙内核).zip)

任务管理相关篇为: 

* [v21.07 鸿蒙内核源码分析(任务控制块) | 内核最重要的概念](/blog/21.md)
* [v22.05 鸿蒙内核源码分析(并发并行) | 如何搞清楚它俩区分](/blog/22.md)
* [v23.03 鸿蒙内核源码分析(就绪队列) | 美好的事物永远值得等待](/blog/23.md)
* [v24.08 鸿蒙内核源码分析(调度机制) | 公平是相对的](/blog/24.md)
* [v25.05 鸿蒙内核源码分析(任务管理) | 如何管理任务池](/blog/25.md)
* [v26.03 鸿蒙内核源码分析(用栈方式) | 谁来提供程序运行场地](/blog/26.md)
* [v27.02 鸿蒙内核源码分析(软件定时器) | 内核最高级任务竟是它](/blog/27.md)
* [v28.01 鸿蒙内核源码分析(控制台) | 一个让很多人模糊的概念](/blog/28.md)
* [v29.01 鸿蒙内核源码分析(远程登录) | 内核如何接待远方的客人](/blog/29.md)
* [v30.01 鸿蒙内核源码分析(协议栈) | 正在制作中 ... ](/blog/30.md)


精读内核源码就绕不过汇编语言，鸿蒙内核有6个汇编文件，读不懂它们就真的很难理解以下问题。

**1.系统调用是如何实现的？**

**2.CPU是如何切换任务和进程上下文的？**

**3.硬件中断是如何处理的？**

**4.main函数到底是怎么来的？**

**5.开机最开始发生了什么？**

**6.关机最后的最后又发生了什么？**

以下是一个很简单的C文件编译成汇编代码后的注解。 读懂这些注解会发现汇编很可爱，甚至还会上瘾，并没有想象中的那么恐怖，读懂它会颠覆你对汇编和栈的认知。

```c
#include <stdio.h>
#include <math.h>

int square(int a，int b){
    return a*b;
}

int fp(int b)
{
    int a = 1;
    return square(a+b，a+b);
}

int main()
{
    int sum = 1;
    for(int a = 0;a < 100; a++){
        sum = sum + fp(a);
    }
    return sum;
}
```

```c
//编译器: armv7-a clang (trunk)
square(int， int):
        sub     sp， sp， #8     @sp减去8，意思为给square分配栈空间，只用2个栈空间完成计算
        str     r0， [sp， #4]   @第一个参数入栈
        str     r1， [sp]       @第二个参数入栈
        ldr     r1， [sp， #4]   @取出第一个参数给r1
        ldr     r2， [sp]       @取出第二个参数给r2
        mul     r0， r1， r2     @执行a*b给R0，返回值的工作一直是交给R0的
        add     sp， sp， #8     @函数执行完了，要释放申请的栈空间
        bx      lr             @子程序返回，等同于mov pc，lr，即跳到调用处
fp(int):
        push    {r11， lr}      @r11(fp)/lr入栈，保存调用者main的位置
        mov     r11， sp        @r11用于保存sp值，函数栈开始位置 
        sub     sp， sp， #8     @sp减去8，意思为给fp分配栈空间，只用2个栈空间完成计算
        str     r0， [sp， #4]   @先保存参数值，放在SP+4，此时r0中存放的是参数
        mov     r0， #1         @r0=1
        str     r0， [sp]       @再把1也保存在SP的位置
        ldr     r0， [sp]       @把SP的值给R0
        ldr     r1， [sp， #4]   @把SP+4的值给R1
        add     r1， r0， r1     @执行r1=a+b
        mov     r0， r1         @r0=r1，用r0，r1传参
        bl      square(int， int)@先mov lr， pc 再mov pc square(int， int)   
        mov     sp， r11        @函数执行完了，要释放申请的栈空间 
        pop     {r11， lr}      @弹出r11和lr，lr是专用标签，弹出就自动复制给lr寄存器
        bx      lr             @子程序返回，等同于mov pc，lr，即跳到调用处
main:
        push    {r11， lr}      @r11(fp)/lr入栈，保存调用者的位置
        mov     r11， sp        @r11用于保存sp值，函数栈开始位置
        sub     sp， sp， #16    @sp减去8，意思为给main分配栈空间，只用2个栈空间完成计算
        mov     r0， #0         @初始化r0
        str     r0， [r11， #-4] @作用是保存SUM的初始值 
        str     r0， [sp， #8]   @sum将始终占用SP+8的位置
        str     r0， [sp， #4]   @a将始终占用SP+4的位置
        b       .LBB1_1        @跳到循环开始位置
.LBB1_1:                       @循环开始位置入口
        ldr     r0， [sp， #4]   @取出a的值给r0
        cmp     r0， #99        @跟99比较
        bgt     .LBB1_4        @大于99，跳出循环 mov pc .LBB1_4
        b       .LBB1_2        @继续循环，直接 mov pc .LBB1_2
.LBB1_2:                       @符合循环条件入口
        ldr     r0， [sp， #8]   @取出sum的值给r0，sp+8用于写SUM的值
        str     r0， [sp]       @先保存SUM的值，SP的位置用于读SUM值
        ldr     r0， [sp， #4]   @r0用于传参，取出A的值给r0作为fp的参数
        bl      fp(int)        @先mov lr， pc再mov pc fp(int)
        mov     r1， r0         @fp的返回值为r0，保存到r1
        ldr     r0， [sp]       @取出SUM的值
        add     r0， r0， r1     @计算新sum的值，由R0保存
        str     r0， [sp， #8]   @将新sum保存到SP+8的位置
        b       .LBB1_3        @无条件跳转，直接 mov pc .LBB1_3
.LBB1_3:                       @完成a++操作入口
        ldr     r0， [sp， #4]   @SP+4中记录是a的值，赋给r0
        add     r0， r0， #1     @r0增加1
        str     r0， [sp， #4]   @把新的a值放回SP+4里去
        b       .LBB1_1        @跳转到比较 a < 100 处
.LBB1_4:                       @循环结束入口
        ldr     r0， [sp， #8]   @最后SUM的结果给R0，返回值的工作一直是交给R0的
        mov     sp， r11        @函数执行完了，要释放申请的栈空间
        pop     {r11， lr}      @弹出r11和lr，lr是专用标签，弹出就自动复制给lr寄存器
        bx      lr             @子程序返回，跳转到lr处等同于 MOV PC， LR

```

这个简单的汇编并不是鸿蒙的汇编，只是先打个底，由浅入深， 但看懂了它基本理解鸿蒙汇编代码没有问题， 后续将详细分析鸿蒙内核各个汇编文件的作用。
开始分析上面的汇编代码。

**第一：** 上面的代码和鸿蒙内核用栈方式一样，都采用了递减满栈的方式， 什么是递减满栈？ 递减指的是栈底地址高于栈顶地址，满栈指的是SP指针永远在栈顶。一定要理解递减满栈，否则读不懂内核汇编代码。举例说明:

```c
square(int， int):
        sub     sp， sp， #8     @sp减去8，意思为给square分配栈空间，只用2个栈空间完成计算
        str     r0， [sp， #4]   @第一个参数入栈
        str     r1， [sp]       @第二个参数入栈
        ldr     r1， [sp， #4]   @取出第一个参数给r1
        ldr     r2， [sp]       @取出第二个参数给r2
        mul     r0， r1， r2     @执行a*b给R0，返回值的工作一直是交给R0的
        add     sp， sp， #8     @函数执行完了，要释放申请的栈空间
        bx      lr             @子程序返回，等同于mov pc，lr，即跳到调用处
```

首句汇编的含义就是申请栈空间， `sp = sp - 8` ，一个栈内单元(栈空间)占4个字节，申请2个栈空间搞定函数的计算，仔细看下代码除了在函数的末尾 `sp = sp + 8` 又恢复在之前的位置的中间过程，SP的值是没有任务变化，它的指向是不动的， 这跟很多人对栈的认知是不一样的，它只是被用于计算，例如
`ldr     r1， [sp， #4]` 的意思是取出SP+4这个虚拟地址的值给r1寄存器，SP的值并没有改变的，为什么要+呢，因为SP是指向栈顶的，地址是最小的。 满栈就是用栈过程中对地址的操作不能超过SP，所以你很少在计算过程中看到 把sp-4地址中的值给某个寄存器， 除非是特别的指令，否则不可能有这样的指令。

**第二：** `sub     sp， sp， #8` 和 `add     sp， sp， #8` 是成对出现的，这就跟申请内存，释放内存的道理一样，这是内核对任务的运行栈管理方式，一样用多少申请多少，用完释放。空间大小就是栈帧，这是栈帧的本质含义。

**第三：** `push    {r11， lr}` 和 `pop     {r11， lr}` 也是成对出现的，主要是用于函数调用，例如 A -> B， B要保存A的栈帧范围和指令位置， lr保存是是A函数执行到哪个指令的位置， r11干了fp的工作，其实就是指向 A的栈顶位置，如此B执行完后return回A的时候，先mov pc，lr 内核就知道改执行A的哪条指令了，同时又知道了A的栈顶位置。

**第四:** 频繁出现的R0寄存器的作用用于传参和返回值， A调用B之前，假如有两个参数，就把参数给`r0 ，r1`记录，充当了A的变量， 到了B中后，先让 `r0，r1`入栈，目的是保存参数值， 因为 B中要用`r0，r1` ，他们变成B的变量用了。 返回值都是默认统一给r0保存。 B中将返回值给r0，回到A中取出R0值对A来说这就是B的返回值。

这是以上为汇编代码的分析，追问两个问题

第一：如果是可变参数怎么办？ 100个参数怎么整， 通过寄存器总共就12个，不够传参啊
第二：返回值可以有多个吗？

### 百文说内核 | 抓住主脉络

* 百文相当于摸出内核的肌肉和器官系统，让人开始丰满有立体感，因是直接从注释源码起步，在加注释过程中，每每有心得处就整理,慢慢形成了以下文章。内容立足源码，常以生活场景打比方尽可能多的将内核知识点置入某种场景，具有画面感，容易理解记忆。说别人能听得懂的话很重要! 百篇博客绝不是百度教条式的在说一堆诘屈聱牙的概念，那没什么意思。更希望让内核变得栩栩如生，倍感亲切。
* 与代码需不断`debug`一样，文章内容会存在不少错漏之处，请多包涵，但会反复修正，持续更新，`v**.xx` 代表文章序号和修改的次数，精雕细琢，言简意赅，力求打造精品内容。
* 百文在 < 鸿蒙研究站 | 开源中国 | 博客园 | 51cto | csdn | 知乎 | 掘金 > 站点发布，百篇博客系列目录如下。
* ![](https://weharmonyos.oss-cn-hangzhou.aliyuncs.com/resources/common/cate.png)

按功能模块:


### 百万注源码 | 处处扣细节

* 百万汉字注解内核目的是要看清楚其毛细血管，细胞结构，等于在拿放大镜看内核。内核并不神秘，带着问题去源码中找答案是很容易上瘾的，你会发现很多文章对一些问题的解读是错误的，或者说不深刻难以自圆其说，你会慢慢形成自己新的解读，而新的解读又会碰到新的问题，如此层层递进，滚滚向前，拿着放大镜根本不愿意放手。
* [< gitee](https://gitee.com/weharmony/kernel_liteos_a_note) | [github](https://github.com/kuangyufei/kernel_liteos_a_note) | [coding](https://weharmony.coding.net/public/harmony/kernel_liteos_a_note/git/files) | [gitcode >](https://gitcode.net/kuangyufei/kernel_liteos_a_note) 四大码仓推送 | 同步官方源码。
  
  [![](https://gitee.com/weharmony/kernel_liteos_a_note/widgets/widget_card.svg?colors=393222,ebdfc1,fffae5,d8ca9f,393222,a28b40)](https://gitee.com/weharmony/kernel_liteos_a_note)

